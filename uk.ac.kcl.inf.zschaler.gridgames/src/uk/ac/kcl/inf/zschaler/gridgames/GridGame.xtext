grammar uk.ac.kcl.inf.zschaler.gridgames.GridGame with org.eclipse.xtext.common.Terminals

generate gridGame "http://www.inf.kcl.ac.uk/zschaler/gridgames/GridGame"

/* 
 * This language is meant to serve as a high-level modelling language for arcade-style games with a grid playing field
 * 
 * Just a bit of fun, really :-)
 * 
 * Initially, the main goal is to use this as a source for code generation, generating a complete implementation from a model-level description
 * 
 * TODO Enable reuse of field initialisers (possibly parametrised) between field specifications
 * TODO Enable more complex behaviour in cell states. For example, allow state changes in one cell to trigger state changes in (selected) surrounding cells etc.
 * TODO Enable keyboard triggers
 * TODO Enable cell movement as an alternative behaviour (to support games like Tetris and Breakout), possibly of cell groups rather than just individual cells
 * TODO Enable timed triggers for behaviours 
 */

GridGame : 
	"game" name=ID "{"
		(states += GlobalCellStateSpec+)?
		cells += CellSpecification+
		fields += FieldSpecification+
		options += OptionSpecification*
	"}"
;
              
CellSpecification :
	"cell" name=ID "{"
		members += CellMember*
	"}";
	
CellMember :
	CellDisplaySpec |
	CellVarSpec |
	CellStateSpec
;

CellDisplaySpec :
	"display" "{"
		"as" display_type=("label" | "button")
		(("text" text=STRING) | 
		 ("var" var=[VarSpec]))
	"}"
;

VarSpec : 
	CellVarSpec |
	StateParamSpec
;

CellVarSpec :
	"var" type=("int"|"String") name=ID	
;

GlobalCellStateSpec :
	"states" name=ID ("(" params += StateParamSpec ("," params += StateParamSpec)* ")")? "{"
		states+=CellState+
		
		"start" "=" start=[CellState]
	"}"
;

StateParamSpec :
	type=("int"|"String"|"Behaviour") name=ID
;

CellStateSpec :
	LocalCellStateSpec |
	CellStateSpecReference
;

LocalCellStateSpec :
	"states" "{"
		states+=CellState+
		
		"start" "=" start=[CellState]
	"}"
;

CellStateSpecReference :
	"states" stateSpec=[GlobalCellStateSpec] ("(" params += Value ("," params += Value)* ")")?
;

Value :
	StringValue |
	IntValue |
	DirectBehaviour |
	VarRefValue
;

StringValue :
	value = STRING 
;

IntValue : 
	value = INT 
;

VarRefValue :
	ref   = [CellVarSpec]
;

CellState :
	name=ID "{"
		display = CellDisplaySpec
		("transitions" "{"
			transitions += TransitionSpec+
		 "}")?
		("onEnter" "{" onEnter += CellStateBehaviour ("," onEnter += CellStateBehaviour)*"}")?
	"}"
;

TransitionSpec :
	"on" trigger=TransitionTriggerSpec "goto" target=[CellState]
;

// TODO Consider introducing triggers based on state changes in the context
TransitionTriggerSpec :
	"mouse-left" | "mouse-right" 
;

CellStateBehaviour :
	DirectBehaviour |
	BehaviourReference
;

BehaviourReference :
	ref=[VarSpec]
;

DirectBehaviour :
	EndGameBehaviour |
	NoOpBehaviour {NoOpBehaviour}
;

EndGameBehaviour :
	"end-game" "(" message=STRING ")"
;

NoOpBehaviour :
	"nop"
;

FieldSpecification :
	"field" name=ID "{" 
		"width" "=" width=INT  
		"height" "=" height=INT 
		field_initialisation = FieldInitialisations? 
    "}"
;

OptionSpecification :
	StartFieldDeclaration | 
	AllowRestartMenu
;

AllowRestartMenu:
	"allow_restart" {AllowRestartMenu}
;

StartFieldDeclaration:
	"start" "=" field = [FieldSpecification]
;

FieldInitialisations :
	"init" "{" (initialisations += FieldInitialisation ";")+ "}" 
;

FieldInitialisation :
	DefaultInitialisation |
	RandomInitialisation |
	ContextInitialisation
;

DefaultInitialisation :
	"default" ":" cell=[CellSpecification]
;

RandomInitialisation :
	"random" ":" cell=[CellSpecification] "=" count=INT
;

// FIXME This should support a number of values, one for each variable defined for the cell type
ContextInitialisation :
	"context" ":" cell=[CellSpecification] "check" check=ContextExpression "value" "=" exp=ContextExpression
;

ContextExpression :
	sub_exp += AtomicExpression ("." sub_exp += AtomicExpression )* 
;

AtomicExpression :
	FilterExpression |
	CountExpression |
	NotEmptyExpression 
;

FilterExpression :
	"filter" "(" cell_type = [CellSpecification] ")"
;

CountExpression :
	"count" "(" ")" {CountExpression}
;

NotEmptyExpression :
	"notEmpty" "(" ")" {NotEmptyExpression}
;